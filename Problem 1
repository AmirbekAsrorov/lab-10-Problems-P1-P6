#include <iostream>
#include <vector>
#include <stdexcept>
using namespace std;

class VectorCompleteTree {
public:
    VectorCompleteTree() : V(1) {}  // V[0] is dummy

    int size() const {
        return V.size() - 1; // number of real elements
    }

    bool empty() const {
        return size() == 0;
    }

    int root() const {
        return 1; // root is always at index 1
    }

    int last() const {
        if (empty()) throw runtime_error("empty tree");
        return size(); // last element index
    }

    int parent(int i) const {
        return i / 2;
    }

    int left(int i) const {
        return 2 * i;
    }

    int right(int i) const {
        return 2 * i + 1;
    }

    bool hasLeft(int i) const {
        return left(i) <= size();
    }

    bool hasRight(int i) const {
        return right(i) <= size();
    }

    bool isRoot(int i) const {
        return i == root();
    }

    int& at(int i) {
        if (i <= 0 || i > size())
            throw out_of_range("invalid index");
        return V[i];
    }

    const int& at(int i) const {
        if (i <= 0 || i > size())
            throw out_of_range("invalid index");
        return V[i];
    }

    void addLast(int e) {
        V.push_back(e);
    }

    void removeLast() {
        if (empty())
            throw runtime_error("empty tree");
        V.pop_back();
    }

    void swapPos(int i, int j) {
        if (i <= 0 || i > size() || j <= 0 || j > size())
            throw out_of_range("invalid index for swap");
        swap(V[i], V[j]);
    }

private:
    vector<int> V; // V[0] unused
};

int main() {
    VectorCompleteTree tree;

    tree.addLast(10);
    tree.addLast(20);
    tree.addLast(30);
    tree.addLast(40);

    cout << "Tree size: " << tree.size() << endl;
    cout << "Root element: " << tree.at(tree.root()) << endl;
    cout << "Last element: " << tree.at(tree.last()) << endl;

    cout << "Parent of index 3: " << tree.at(tree.parent(3)) << endl;
    cout << "Has left child (index 2): " << tree.hasLeft(2) << endl;
    cout << "Has right child (index 2): " << tree.hasRight(2) << endl;

    tree.swapPos(2, 3);
    cout << "After swap, element at 2: " << tree.at(2) << ", at 3: " << tree.at(3) << endl;

    tree.removeLast();
    cout << "Size after remove: " << tree.size() << endl;

    return 0;
}
