#include <iostream>
#include <vector>
#include <stdexcept>
using namespace std;

class VectorCompleteTree {
public:
    VectorCompleteTree() : V(1) {} 

    int size() const { return V.size() - 1; }
    bool empty() const { return size() == 0; }
    int root() const { return 1; }
    int last() const { return size(); }

    int parent(int i) const { return i / 2; }
    int left(int i) const { return 2 * i; }
    int right(int i) const { return 2 * i + 1; }

    bool hasLeft(int i) const { return left(i) <= size(); }
    bool hasRight(int i) const { return right(i) <= size(); }
    bool isRoot(int i) const { return i == 1; }

    int& at(int i) {
        if (i <= 0 || i > size()) throw out_of_range("invalid index");
        return V[i];
    }
    const int& at(int i) const {
        if (i <= 0 || i > size()) throw out_of_range("invalid index");
        return V[i];
    }

    void addLast(int e) { V.push_back(e); }
    void removeLast() {
        if (empty()) throw runtime_error("empty tree");
        V.pop_back();
    }

    void swapPos(int i, int j) {
        if (i <= 0 || i > size() || j <= 0 || j > size()) throw out_of_range("invalid index");
        swap(V[i], V[j]);
    }

private:
    vector<int> V; // V[0] unused
};


class HeapPriorityQueue {
public:
    int size() const {
        return T.size();
    }

    bool empty() const {
        return T.empty();
    }

    const int& min() const {
        if (empty()) throw runtime_error("empty heap");
        return T.at(T.root());
    }

    void insert(int e) {
        // 1. add element at the end
        T.addLast(e);
        // 2. perform upheap from position T.last()
        upheap(T.last());
    }

    void removeMin() {
        if (empty()) {
            cout << "empty heap" << endl;
            return;
        }

        if (T.size() == 1) {
            T.removeLast();
            return;
        }

        // 1. swap root and last
        T.swapPos(T.root(), T.last());
        // 2. remove last
        T.removeLast();
        // 3. downheap from root
        downheap(T.root());
    }

private:
    VectorCompleteTree T;

    static bool isLess(int a, int b) { return a < b; }

    void upheap(int i) {
        while (!T.isRoot(i)) {
            int p = T.parent(i);
            if (!isLess(T.at(i), T.at(p))) break;
            T.swapPos(i, p);
            i = p;
        }
    }

    void downheap(int i) {
        while (T.hasLeft(i)) {
            int left = T.left(i);
            int smallChild = left;
            if (T.hasRight(i)) {
                int right = T.right(i);
                if (isLess(T.at(right), T.at(left)))
                    smallChild = right;
            }
            if (!isLess(T.at(smallChild), T.at(i))) break;
            T.swapPos(i, smallChild);
            i = smallChild;
        }
    }
};

int main() {
    HeapPriorityQueue pq;
    pq.insert(5);
    pq.insert(2);
    pq.insert(7);
    pq.insert(3);

    while (!pq.empty()) {
        cout << pq.min() << " ";
        pq.removeMin();
    }
    cout << "\n"; 

    return 0;
}
